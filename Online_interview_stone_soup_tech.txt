https://www.interviewzen.com/interview/3kQ9RcW


Stefan Cobeli


Total duration: 83:33


Question 1

Given an array of integers, determine the pair of elements that have the maximum product.

For example, given [5, 2, -3, 1, 8], the answer is [5, 8].

-------------

Please discuss the time and space complexity of your solution. Is your solution an optimal one? If not, why did you choose it and what would an optimal solution look like?

Make sure your code works for edge cases, especially those particular to your problem.

If anything is ambiguous or unclear, then state that as a comment in the code box, make an assumption as to what would be a reasonable answer and follow it.


"""
Variable declaration:
array                              -> will be the given one
maximum_positive                   -> the greatest positive number from "array"
smallest_negative                   -> the smallest negative number from "array"

maximum2_positive                   -> the second greatest positive number from "array"
smallest2_negative                   -> the second smallest negative number from "array"

I will make a function  that computes the requested value.
I will consider, that if we have less than two elements in the array, the requested value will be "0" .
"""

def maximum_product( array ):
    

    maximum_positive = 0
    maximum2_positive = 0
    smallest_negative = 0
    smallest2_negative = 0

    if len(array) < 2 :
        return 0
    
    if len(array) == 2 :
        return array[0] * array[1] 

    for element in array :
        if element < 0 :
            if element < smallest_negative :
                smallest_negative = element
            else :
                if element < smallest2_negative :
                    smallest2_negative = element
        else :
            if element > 0 :
                if element > maximum_positive :
                    maximum_positive = element
                else :
                    if element < maximum2_positive :
                        maximum2_positive = element
            
    result_positive =  maximum_positive * maximum2_positive 
    result_negative = smallest_negative * smallest2_negative
    
    if result_positive > result_negative :
        return result_positive
    return result_negative
    
    
"    The time and the space complexity is O( len(array) ) because we go through the array only one time and we make a 
"  computation for each position. We treated the special cases separatly.


0:00 / 29:55 




 


play

1x

2x

5x


Question 2

Given an array of integers, update the array by moving all the zeros to the left. The order of the other elements doesn't matter.

For example, given the input [5, 0, 2, 1, 4, 0], a valid output would be [0, 0, 2, 4, 5, 1].

-------------

Please discuss the time and space complexity of your solution. Is your solution an optimal one? If not, why did you choose it and what would an optimal solution look like?

Make sure your code works for edge cases, especially those particular to your problem.

If anything is ambiguous or unclear, then state that as a comment in the code box, make an assumption as to what would be a reasonable answer and follow it.


/*

I' ve made a block of code like the one in the tutorial. 
Where array is the given input and flag tells us the last position of 0 fromleft to right.
We pass through the array and when we meet a 0 we make swap with the postion of the flag and we move the flag with one position.

Again, the Complexity is O( array.length ) as it was inthe previous question, because we pass through the array only once.

 */

int flag = 0 ;


for( int index = 0; index < array.length; index ++  ){
    
    if( array[index] == 0 ){
        array[ index ] = array[ flag ] ;
        array[ flag ] = 0 ;
        flag ++ ;
    }
    
    
}


0:00 / 20:00 




 


play

1x

2x

5x


Question 3

Given an array of non-negative integers and a target number, find out whether there is a set of consecutive elements in the array that add up to the target. 

Example: 
Given the array [1, 3, 5, 7, 3],
- for target = 8, the output is true ([3, 5]) 
- for target = 15, the output is true ([3, 5, 7])
- for target = 6, the output is false

-------------

Please discuss the time and space complexity of your solution. Is your solution an optimal one? If not, why did you choose it and what would an optimal solution look like?

Make sure your code works for edge cases, especially those particular to your problem.

If anything is ambiguous or unclear, then state that as a comment in the code box, make an assumption as to what would be a reasonable answer and follow it.


/*

I've made a function that computes the requsted value. 
myArray and target are the given data.

I go through myArray only once and for every element I compute if he is in the posible sum and retain the value in sumArray.
If I found the target in the sumArray I stop the search.

The complexity in time is O( myArray.length ^ 2 ) because in the worst case I cross all the elements of the array
and for every element I make almost myArray.length computations. The complexity in space is O( myArray.length ) because
I use two arrays of length myArray.length.

*/
boolean compute_result( int[] myArray, int target ){

    int[] sumArray = new int[myArray.length] ;
    int flag = 0 ;
    
    for( int index = 0; index < myArray.length; index++ ){
        flag++;
        for( int jndex = 0; jndex < flag; jndex++ ){
            
            sumArray[ jndex ] += myArray[ index ];
            if( sumArray[ jndex ] == target )
                return true;
            
        }
        
    }
    return false
    
}


0:00 / 33:26 




 


play

1x

2x

5x